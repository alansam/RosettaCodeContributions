/* NetRexx */
options replace format comments java crossref symbols nobinary

/**
 * @see <a href="http://rosettacode.org/wiki/Call_a_foreign-language_function#Java">Call a foreign-language function - Rosetta Code</a>
 * @see <a href="http://pujansrt.blogspot.com/2010/04/creating-jni-library-on-mac-osx-from-c.html">Creating JNI Library on Mac OSX from C and H files</a>
 * @see <a href="http://kenai.com/jira/browse/NETREXX-88">NetRexx bug NETREXX-88: The NATIVE and STATIC modifiers of the METHOD instruction should not be mutually exclusive</a>
 */
class RJNIDemo
  properties constant
    libraryName = clinit('RJNIDemo') -- NetRexx doesn't support "static initializer" but we can fake it here

  /** Main */
  method main(args = String[]) public static
    say (RJNIDemo()).jniFunc('Hello World!')
    return

  /** JNI Function definition */
  method jniFunc(s = String) private native returns String

  /** Class initializer */
  method clinit(libName = String) constant binary returns String
    System.loadLibrary(libName)
    return libName

/*

First, we start generate the java source code:
nrc -keepasjava -savelog RJNIDemo

public class RJNIDemo{
 private static final java.lang.String $0="RJNIDemo.nrx";
 /-*- properties constant -*-/
 protected static final boolean init=clinit();

 
 
 public static void main(java.lang.String args[]){
  netrexx.lang.RexxIO.Say((new RJNIDemo()).jniFunc("Hello World!"));
  return;
  }

 
 private native java.lang.String jniFunc(java.lang.String s);

 
 
 public static final boolean clinit(){
  java.lang.System.loadLibrary("RJNIDemo");
  return (1==1);
  }
 
 public RJNIDemo(){return;}
 }



Two things to note: First, the "native" stub which will be linked with a native library, and second,
the call to System.loadLibrary to actually do the linking at runtime.
The class must then be compiled without the native library.
Next, a C-style ".h" file needs to be created from the class.
This can be done by running javah on our compiled class:

javah -jni RJNIDemo

The generated file, JNIDemo.h:

/-*- DO NOT EDIT THIS FILE - it is machine generated -*-/
#include <jni.h>
/-*- Header for class JNIDemo -*-/
 
#ifndef _Included_JNIDemo
#define _Included_JNIDemo
#ifdef __cplusplus
extern "C" {
#endif
/-*-
 -*- Class:     JNIDemo
 -*- Method:    callStrdup
 -*- Signature: (Ljava/lang/String;)Ljava/lang/String;
 -*-/
JNIEXPORT jstring JNICALL Java_JNIDemo_callStrdup
  (JNIEnv *, jclass, jstring);
 
#ifdef __cplusplus
}
#endif
#endif
Next, the C code which utilizes JNI to bridge between the managed and unmanaged environments.
It should include the "h" file, and implement the exported function declared in that file.
The specifics of writing JNI code are beyond the scope of this task.
JNIDemo.c


#include <string.h>
#include "RJNIDemo.h"

void throwByName(JNIEnv * env, char const * className, char const * msg)
{
  jclass exceptionClass = (*env)->FindClass(env, className);
  if (exceptionClass != NULL)
  {
    (*env)->ThrowNew(env, exceptionClass, msg);
    (*env)->DeleteLocalRef(env, exceptionClass);
  }
  return;
}

JNIEXPORT jstring JNICALL Java_RJNIDemo_jniFunc(JNIEnv * env, jobject obj, jstring s)
{
  jbyte const * utf8String;
  char * dupe;
  jstring dupeString;
 
  if (s == NULL)
  {
    throwByName(env, "java/lang/NullPointerException", "String is null");
    return NULL;
  }

  // Convert from UTF-16 to UTF-8 (C-style)
  utf8String = (*env)->GetStringUTFChars(env, s, NULL);
 
  // Duplicate
  dupe = strdup(utf8String);
 
  // Free the UTF-8 string back to the JVM
  (*env)->ReleaseStringUTFChars(env, s, utf8String);
 
  // Convert the duplicate string from strdup to a Java String
  dupeString = (*env)->NewStringUTF(env, dupe);
 
  // Free the duplicate c-string back to the C runtime heap
  free(dupe);
 
  return dupeString;
}

In a Windows environment, a dll by the same name should be created ("JNIDemo.dll").

In a Linux environment, a shared object marked executable and with a name preceded by "lib" should be created (in this case, "libJNIDemo.so").
Your compiler will need to know the location of "jni.h", which is in the "include" directory of the JDK.

Linux may also need includes that are in the "include/linux" directory. Linux example using gcc:

gcc -shared -fPIC -I/usr/jdk/include -I/usr/jdk/include/linux -o libJNIDemo.so JNIDemo.c

[ Mac OS X Darwin (BSD)
---- NO! gcc --shared -fPIC -g -c -I /System/Library/Frameworks/JavaVM.framework/Versions/A/Headers -I . -o libRJNIDemo.so RJNIDemo.c

gcc -g -c -I /System/Library/Frameworks/JavaVM.framework/Versions/A/Headers RJNIDemo.c
gcc -dynamiclib -o libRJNIDemo.jnilib RJNIDemo.o -framework JavaVM

]

And finally, to run the program, the library must be in the runtime's library path.
If the directory in which the library resides is not in this path, it can be explicitly specified using the "-D" option
(e.g. "-Djava.library.path=." would specify the current directory as the library path).

java -Djava.library.path=. RJNIDemo
Hello World!

 */

